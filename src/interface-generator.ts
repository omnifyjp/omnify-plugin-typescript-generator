/**
 * @famgia/omnify-laravel - TypeScript Interface Generator
 *
 * Generates TypeScript interfaces from schemas.
 */

import type { LoadedSchema, PropertyDefinition, SchemaCollection, LocalizedString } from '@famgia/omnify-types';
import { resolveLocalizedString } from '@famgia/omnify-types';
import type { TSInterface, TSProperty, TypeScriptOptions } from './types.js';

/**
 * Convert a string to snake_case.
 */
export function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .replace(/^_/, '')
    .toLowerCase();
}

/**
 * Maps Omnify property types to TypeScript types.
 */
const TYPE_MAP: Record<string, string> = {
  String: 'string',
  TinyInt: 'number',
  Int: 'number',
  BigInt: 'number',
  Float: 'number',
  Boolean: 'boolean',
  Text: 'string',
  MediumText: 'string',
  LongText: 'string',
  Date: 'DateString',
  Time: 'string',
  DateTime: 'DateTimeString',
  Timestamp: 'DateTimeString',
  Json: 'unknown',
  Email: 'string',
  Password: 'string',
  Enum: 'string',
  Select: 'string',
  Lookup: 'number',
};

/**
 * File interface name (references the File.yaml schema).
 * The File schema is auto-generated by ensureFileSchema() when File type is used.
 */
export const FILE_INTERFACE_NAME = 'File';

/**
 * Maps primary key types to TypeScript types.
 */
const PK_TYPE_MAP: Record<string, string> = {
  Int: 'number',
  BigInt: 'number',
  Uuid: 'string',
  String: 'string',
};

/**
 * Resolves a localized string using the given options.
 * Returns undefined if the value is undefined or cannot be resolved.
 */
function resolveDisplayName(
  value: LocalizedString | undefined,
  options: TypeScriptOptions = {}
): string | undefined {
  if (value === undefined) {
    return undefined;
  }
  return resolveLocalizedString(value, {
    locale: options.locale,
    config: options.localeConfig,
  });
}

/**
 * Converts property name to TypeScript property name.
 * Preserves camelCase.
 */
export function toPropertyName(name: string): string {
  return name;
}

/**
 * Converts schema name to TypeScript interface name.
 * Preserves PascalCase.
 */
export function toInterfaceName(schemaName: string): string {
  return schemaName;
}

/**
 * Gets TypeScript type for a property.
 */
export function getPropertyType(
  property: PropertyDefinition,
  _allSchemas: SchemaCollection
): string {
  // Handle File type specially (polymorphic relation to files table)
  // References the File interface generated from File.yaml schema
  if (property.type === 'File') {
    const fileProp = property as { multiple?: boolean };
    if (fileProp.multiple) {
      return `${FILE_INTERFACE_NAME}[]`;
    }
    return `${FILE_INTERFACE_NAME} | null`;
  }

  // Handle associations
  if (property.type === 'Association') {
    const assocProp = property as {
      relation?: string;
      target?: string;
      targets?: readonly string[];
    };

    const targetName = assocProp.target ?? 'unknown';

    switch (assocProp.relation) {
      // Standard relations
      case 'OneToOne':
      case 'ManyToOne':
        return targetName;
      case 'OneToMany':
      case 'ManyToMany':
        return `${targetName}[]`;

      // Polymorphic relations
      case 'MorphTo':
        // Union type of all possible targets
        if (assocProp.targets && assocProp.targets.length > 0) {
          return assocProp.targets.join(' | ');
        }
        return 'unknown';
      case 'MorphOne':
        return targetName;
      case 'MorphMany':
      case 'MorphToMany':
      case 'MorphedByMany':
        return `${targetName}[]`;

      default:
        return 'unknown';
    }
  }

  // Handle EnumRef types (reference to shared enum schema)
  if (property.type === 'EnumRef') {
    const enumRefProp = property as { enum: string };
    return enumRefProp.enum;
  }

  // Handle enum types
  if (property.type === 'Enum') {
    const enumProp = property as { enum?: string | readonly string[] };
    if (typeof enumProp.enum === 'string') {
      // Reference to a named enum
      return enumProp.enum;
    }
    if (Array.isArray(enumProp.enum)) {
      // Inline enum - create union type
      return enumProp.enum.map(v => `'${v}'`).join(' | ');
    }
  }

  // Handle Select with options
  if (property.type === 'Select') {
    const selectProp = property as { options?: readonly string[] };
    if (selectProp.options && selectProp.options.length > 0) {
      return selectProp.options.map(v => `'${v}'`).join(' | ');
    }
  }

  // Standard type mapping
  return TYPE_MAP[property.type] ?? 'unknown';
}

/**
 * Converts a property to TypeScript property definition.
 * For MorphTo, returns multiple properties (_type, _id, and relation).
 * For compound custom types, expands to multiple properties.
 */
export function propertyToTSProperties(
  propertyName: string,
  property: PropertyDefinition,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSProperty[] {
  const baseProp = property as { nullable?: boolean; displayName?: LocalizedString; fields?: Record<string, { nullable?: boolean }> };
  const isReadonly = options.readonly ?? true;
  // Resolve displayName using locale config
  const displayName = resolveDisplayName(baseProp.displayName, options);

  // Handle custom compound types from plugins (e.g., JapaneseName, JapaneseAddress)
  if (options.customTypes) {
    const customType = options.customTypes.get(property.type);
    if (customType?.compound && customType.expand) {
      const expandedProps: TSProperty[] = [];
      for (const field of customType.expand) {
        const fieldName = `${propertyName}_${toSnakeCase(field.suffix)}`;
        const fieldOverride = baseProp.fields?.[field.suffix];
        // Nullable priority: schema field override > plugin field default > parent property > false
        const isNullable = fieldOverride?.nullable ?? field.sql?.nullable ?? baseProp.nullable ?? false;
        const tsType = field.typescript?.type ?? 'string';

        expandedProps.push({
          name: fieldName,
          type: tsType,
          optional: isNullable,
          readonly: isReadonly,
          comment: `${displayName ?? propertyName} (${field.suffix})`,
        });
      }

      // Add accessor properties (computed properties like full_name)
      if (customType.accessors) {
        for (const accessor of customType.accessors) {
          const accessorName = `${propertyName}_${toSnakeCase(accessor.name)}`;
          expandedProps.push({
            name: accessorName,
            type: 'string | null',
            optional: true,
            readonly: isReadonly,
            comment: `${displayName ?? propertyName} (computed)`,
          });
        }
      }

      return expandedProps;
    }
    // Handle simple custom types (non-compound)
    if (customType && !customType.compound) {
      const tsType = customType.typescript?.type ?? 'string';
      return [{
        name: toPropertyName(propertyName),
        type: tsType,
        optional: baseProp.nullable ?? false,
        readonly: isReadonly,
        comment: displayName,
      }];
    }
  }

  // Handle MorphTo specially - it creates _type and _id columns
  if (property.type === 'Association') {
    const assocProp = property as {
      relation?: string;
      targets?: readonly string[];
    };

    if (assocProp.relation === 'MorphTo' && assocProp.targets && assocProp.targets.length > 0) {
      const propBaseName = toPropertyName(propertyName);
      const targetUnion = assocProp.targets.map(t => `'${t}'`).join(' | ');
      const relationUnion = assocProp.targets.join(' | ');

      return [
        {
          name: `${propBaseName}Type`,
          type: targetUnion,
          optional: true, // Polymorphic columns are nullable
          readonly: isReadonly,
          comment: `Polymorphic type for ${propertyName}`,
        },
        {
          name: `${propBaseName}Id`,
          type: 'number',
          optional: true,
          readonly: isReadonly,
          comment: `Polymorphic ID for ${propertyName}`,
        },
        {
          name: propBaseName,
          type: `${relationUnion} | null`,
          optional: true,
          readonly: isReadonly,
          comment: displayName ?? `Polymorphic relation to ${assocProp.targets.join(', ')}`,
        },
      ];
    }
  }

  // Default: single property
  const type = getPropertyType(property, allSchemas);

  return [{
    name: toPropertyName(propertyName),
    type,
    optional: baseProp.nullable ?? false,
    readonly: isReadonly,
    comment: displayName,
  }];
}

/**
 * Converts a property to TypeScript property definition (legacy - returns single property).
 */
export function propertyToTSProperty(
  propertyName: string,
  property: PropertyDefinition,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSProperty {
  return propertyToTSProperties(propertyName, property, allSchemas, options)[0]!;
}

/**
 * Extracts referenced interface names from a TypeScript type string.
 * Returns only interface names (not primitives like string, number, boolean, unknown).
 */
function extractTypeReferences(type: string, allSchemaNames: Set<string>): string[] {
  const primitives = new Set(['string', 'number', 'boolean', 'unknown', 'null', 'undefined', 'void', 'never', 'any']);
  const refs: string[] = [];

  // Remove array notation and split by | for union types
  const cleanType = type.replace(/\[\]/g, '').replace(/\s*\|\s*null/g, '');
  const parts = cleanType.split(/\s*\|\s*/);

  for (const part of parts) {
    // Remove quotes (for string literal types like 'Post')
    const trimmed = part.trim().replace(/^['"]|['"]$/g, '');
    if (!primitives.has(trimmed) && allSchemaNames.has(trimmed)) {
      refs.push(trimmed);
    }
  }

  return refs;
}

/**
 * Generates TypeScript interface from schema.
 */
export function schemaToInterface(
  schema: LoadedSchema,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSInterface {
  const properties: TSProperty[] = [];
  const allSchemaNames = new Set(Object.keys(allSchemas).filter(name => allSchemas[name]!.kind !== 'enum'));

  // ID property (only if id is not disabled)
  if (schema.options?.id !== false) {
    const pkType = (schema.options?.idType ?? 'BigInt') as keyof typeof PK_TYPE_MAP;
    properties.push({
      name: 'id',
      type: PK_TYPE_MAP[pkType] ?? 'number',
      optional: false,
      readonly: options.readonly ?? true,
      comment: 'Primary key',
    });
  }

  // Schema properties
  if (schema.properties) {
    for (const [propName, property] of Object.entries(schema.properties)) {
      // Use propertyToTSProperties which handles MorphTo returning multiple properties
      properties.push(...propertyToTSProperties(propName, property, allSchemas, options));
    }
  }

  // Timestamps (snake_case to match database columns)
  if (schema.options?.timestamps !== false) {
    properties.push(
      {
        name: 'created_at',
        type: 'DateTimeString',
        optional: true,
        readonly: options.readonly ?? true,
        comment: 'Creation timestamp',
      },
      {
        name: 'updated_at',
        type: 'DateTimeString',
        optional: true,
        readonly: options.readonly ?? true,
        comment: 'Last update timestamp',
      }
    );
  }

  // Soft delete (snake_case to match database columns)
  if (schema.options?.softDelete) {
    properties.push({
      name: 'deleted_at',
      type: 'DateTimeString',
      optional: true,
      readonly: options.readonly ?? true,
      comment: 'Soft delete timestamp',
    });
  }

  // Collect dependencies from property types
  const dependencySet = new Set<string>();
  for (const prop of properties) {
    for (const ref of extractTypeReferences(prop.type, allSchemaNames)) {
      if (ref !== schema.name) { // Don't include self-references
        dependencySet.add(ref);
      }
    }
  }

  // Collect enum dependencies from EnumRef properties
  const enumDependencySet = new Set<string>();
  if (schema.properties) {
    for (const property of Object.values(schema.properties)) {
      if (property.type === 'EnumRef') {
        const enumRefProp = property as { enum: string };
        if (enumRefProp.enum) {
          enumDependencySet.add(enumRefProp.enum);
        }
      }
    }
  }

  // Resolve schema displayName using locale config
  const schemaDisplayName = resolveDisplayName(schema.displayName, options);

  return {
    name: toInterfaceName(schema.name),
    properties,
    comment: schemaDisplayName ?? schema.name,
    dependencies: dependencySet.size > 0 ? Array.from(dependencySet).sort() : undefined,
    enumDependencies: enumDependencySet.size > 0 ? Array.from(enumDependencySet).sort() : undefined,
  };
}

/**
 * Formats a TypeScript property.
 */
export function formatProperty(property: TSProperty): string {
  const readonly = property.readonly ? 'readonly ' : '';
  const optional = property.optional ? '?' : '';
  const comment = property.comment ? `  /** ${property.comment} */\n` : '';
  return `${comment}  ${readonly}${property.name}${optional}: ${property.type};`;
}

/**
 * Formats a TypeScript interface.
 */
export function formatInterface(iface: TSInterface): string {
  const comment = iface.comment ? `/**\n * ${iface.comment}\n */\n` : '';
  const extendsClause = iface.extends && iface.extends.length > 0
    ? ` extends ${iface.extends.join(', ')}`
    : '';
  const properties = iface.properties.map(formatProperty).join('\n');

  return `${comment}export interface ${iface.name}${extendsClause} {\n${properties}\n}`;
}

/**
 * Generates interfaces for all schemas.
 * Note: File interface is now generated from File.yaml schema (use ensureFileSchema() to auto-create it).
 */
export function generateInterfaces(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSInterface[] {
  const interfaces: TSInterface[] = [];

  for (const schema of Object.values(schemas)) {
    // Skip enum schemas
    if (schema.kind === 'enum') {
      continue;
    }

    // Skip hidden schemas (e.g., cache, jobs, sessions)
    if (schema.options?.hidden === true) {
      continue;
    }

    interfaces.push(schemaToInterface(schema, schemas, options));
  }

  return interfaces;
}
