/**
 * @famgia/omnify-typescript - TypeScript Generator
 *
 * Generates TypeScript models with base/model pattern:
 * - models/base/[SchemaName].ts - Auto-generated base interfaces, DO NOT EDIT
 * - models/enum/[EnumName].ts - Auto-generated enums/type aliases, DO NOT EDIT
 * - models/[SchemaName].ts - Extends base, user can customize
 * - models/index.ts - Re-exports all
 */

import type { SchemaCollection } from '@famgia/omnify-types';
import type { TypeScriptFile, TypeScriptOptions, TSEnum, TSTypeAlias } from './types.js';
import { generateInterfaces, formatInterface, toSnakeCase } from './interface-generator.js';
import { generateEnums, generatePluginEnums, formatEnum, formatTypeAlias, extractInlineEnums } from './enum-generator.js';
import { generateRulesFiles } from './rules-generator.js';
import {
  generateZodSchemas,
  generateDisplayNames,
  getExcludedFields,
  formatZodSchemasSection,
  formatZodModelFile,
} from './zod-generator.js';

/**
 * Default options for TypeScript generation.
 */
const DEFAULT_OPTIONS: TypeScriptOptions = {
  readonly: false, // Changed: interfaces should be mutable for forms/mutations
  strictNullChecks: true,
  generateZodSchemas: true, // Generate Zod schemas by default
  generateRules: false, // Legacy Ant Design rules (deprecated, ignored when generateZodSchemas=true)
  useJsExtension: false, // Bundlers (Vite, webpack) don't need .js extension
};

/**
 * Gets file extension for imports based on options.
 * Returns '.js' for native ESM, empty string for bundlers.
 */
function getImportExt(options: TypeScriptOptions): string {
  return options.useJsExtension ? '.js' : '';
}

/**
 * Generates the base file header comment (DO NOT EDIT).
 */
function generateBaseHeader(): string {
  return `/**
 * ⚠️ DO NOT EDIT THIS FILE! ⚠️
 * このファイルを編集しないでください！
 * KHÔNG ĐƯỢC SỬA FILE NÀY!
 *
 * Auto-generated TypeScript types from Omnify schemas.
 * Any manual changes will be OVERWRITTEN on next generation.
 *
 * To modify: Edit the schema YAML file and run: npx omnify generate
 */

`;
}

/**
 * Generates the model file header comment (user can edit).
 */
function generateModelHeader(schemaName: string): string {
  return `/**
 * ${schemaName} Model
 *
 * This file extends the auto-generated base interface.
 * You can add custom methods, computed properties, or override types here.
 * This file will NOT be overwritten by the generator.
 */

`;
}

/**
 * Collects all computed field names from a schema.
 * Includes accessor fields from compound types.
 */
function getComputedFields(
  schema: { properties?: Record<string, { type: string }> },
  customTypes: ReadonlyMap<string, { accessors?: readonly { name: string }[] }> | undefined
): string[] {
  const computedFields: string[] = [];
  if (!schema.properties) return computedFields;

  for (const [propName, propDef] of Object.entries(schema.properties)) {
    const snakeName = toSnakeCase(propName);
    const customType = customTypes?.get(propDef.type);

    // Add accessor fields from compound types
    if (customType?.accessors) {
      for (const accessor of customType.accessors) {
        computedFields.push(`${snakeName}_${toSnakeCase(accessor.name)}`);
      }
    }
  }

  return computedFields;
}

/**
 * Generates utility types for a schema.
 * - Create: For POST requests (excludes id, timestamps, computed fields, server-managed fields)
 * - Update: For PUT/PATCH requests (all fields optional)
 */
function generateUtilityTypes(
  schemaName: string,
  schema: { options?: { id?: boolean; timestamps?: boolean; softDelete?: boolean }; properties?: Record<string, { type: string }> },
  customTypes?: ReadonlyMap<string, { accessors?: readonly { name: string }[] }>
): string {
  const parts: string[] = [];
  const excludeFields: string[] = [];

  // Exclude id if auto-generated
  if (schema.options?.id !== false) {
    excludeFields.push("'id'");
  }

  // Exclude timestamps if enabled
  if (schema.options?.timestamps !== false) {
    excludeFields.push("'created_at'", "'updated_at'");
  }

  // Exclude soft delete if enabled
  if (schema.options?.softDelete) {
    excludeFields.push("'deleted_at'");
  }

  // Exclude email_verified_at (server-managed field)
  if (schema.properties?.['emailVerifiedAt'] || schema.properties?.['email_verified_at']) {
    excludeFields.push("'email_verified_at'");
  }

  // Exclude computed fields from compound types
  const computedFields = getComputedFields(schema, customTypes);
  for (const field of computedFields) {
    excludeFields.push(`'${field}'`);
  }

  const omitType = excludeFields.length > 0
    ? `Omit<${schemaName}, ${excludeFields.join(' | ')}>`
    : schemaName;

  // Create type - for POST requests
  parts.push(`\n/** For creating new ${schemaName} (POST requests) */`);
  parts.push(`\nexport type ${schemaName}Create = ${omitType};\n`);

  // Update type - for PUT/PATCH requests (all optional)
  parts.push(`\n/** For updating ${schemaName} (PUT/PATCH requests) */`);
  parts.push(`\nexport type ${schemaName}Update = Partial<${schemaName}Create>;\n`);

  return parts.join('');
}

/**
 * Checks if interface uses DateTimeString or DateString types.
 */
function needsDateTimeImports(iface: { properties: readonly { type: string }[] }): { dateTime: boolean; date: boolean } {
  let dateTime = false;
  let date = false;
  for (const prop of iface.properties) {
    if (prop.type === 'DateTimeString' || prop.type.includes('DateTimeString')) {
      dateTime = true;
    }
    if (prop.type === 'DateString' || prop.type.includes('DateString')) {
      date = true;
    }
  }
  return { dateTime, date };
}

/**
 * Generates a single base interface file.
 */
function generateBaseInterfaceFile(
  schemaName: string,
  schemas: SchemaCollection,
  options: TypeScriptOptions
): TypeScriptFile {
  const interfaces = generateInterfaces(schemas, options);
  const iface = interfaces.find(i => i.name === schemaName);
  const schema = schemas[schemaName];

  if (!iface || !schema) {
    throw new Error(`Interface not found for schema: ${schemaName}`);
  }

  const parts: string[] = [generateBaseHeader()];

  // Add Zod import if generating Zod schemas
  if (options.generateZodSchemas) {
    parts.push(`import { z } from 'zod';\n`);
  }

  // Check if we need to import DateTimeString or DateString
  const dateImports = needsDateTimeImports(iface);
  const commonImports: string[] = [];
  if (dateImports.dateTime) commonImports.push('DateTimeString');
  if (dateImports.date) commonImports.push('DateString');
  const ext = getImportExt(options);
  // When base files are in node_modules, common.ts is alongside them (./common)
  // Otherwise it's in parent folder (../common)
  const isNodeModulesBase = options.baseImportPrefix?.startsWith('@');
  const commonImportPath = isNodeModulesBase ? './common' : '../common';
  if (commonImports.length > 0) {
    parts.push(`import type { ${commonImports.join(', ')} } from '${commonImportPath}${ext}';\n`);
  }

  // Add imports for enum dependencies
  if (iface.enumDependencies && iface.enumDependencies.length > 0) {
    // Schema enum prefix: use schemaEnumImportPrefix if provided (for node_modules base files)
    // Otherwise use relative path from base/ folder
    const schemaEnumPrefix = options.schemaEnumImportPrefix
      ?? (options.enumImportPrefix ? `../${options.enumImportPrefix}` : '../enum');
    // Build set of plugin enum names for path resolution
    const pluginEnumNames = new Set(
      options.pluginEnums ? Array.from(options.pluginEnums.keys()) : []
    );
    // Plugin enum import prefix (for node_modules/@omnify-client/enum)
    const pluginEnumPrefix = options.pluginEnumImportPrefix ?? `${schemaEnumPrefix}/plugin`;
    for (const enumName of iface.enumDependencies) {
      // Plugin enums use pluginEnumImportPrefix, schema enums use schemaEnumPrefix
      const enumPath = pluginEnumNames.has(enumName)
        ? `${pluginEnumPrefix}/${enumName}${ext}`
        : `${schemaEnumPrefix}/${enumName}${ext}`;
      parts.push(`import { ${enumName} } from '${enumPath}';\n`);
    }
  }

  // Add imports for dependencies
  if (iface.dependencies && iface.dependencies.length > 0) {
    for (const dep of iface.dependencies) {
      parts.push(`import type { ${dep} } from './${dep}${ext}';\n`);
    }
    parts.push('\n');
  } else if (commonImports.length > 0 || options.generateZodSchemas || (iface.enumDependencies && iface.enumDependencies.length > 0)) {
    parts.push('\n');
  }

  // Main interface
  parts.push(formatInterface(iface));
  parts.push('\n');

  // Generate Zod schemas if enabled
  if (options.generateZodSchemas) {
    const zodSchemas = generateZodSchemas(schema, options);
    const displayNames = generateDisplayNames(schema, options);
    const excludedFields = getExcludedFields(schema, options.customTypes);
    parts.push('\n');
    parts.push(formatZodSchemasSection(schemaName, zodSchemas, displayNames, excludedFields));
  } else {
    // Legacy: Utility types (Create, Update) without Zod
    parts.push(generateUtilityTypes(schemaName, schema, options.customTypes));
  }

  return {
    filePath: `base/${schemaName}.ts`,
    content: parts.join(''),
    types: [schemaName, `${schemaName}Create`, `${schemaName}Update`],
    overwrite: true,
    category: 'base' as const,
  };
}

/**
 * Generates a single enum file.
 * @param enumDef - The enum definition
 * @param isPluginEnum - If true, uses 'plugin-enum' category for node_modules/@omnify-client output
 */
function generateEnumFile(enumDef: TSEnum, isPluginEnum = false): TypeScriptFile {
  const parts: string[] = [generateBaseHeader()];
  parts.push(formatEnum(enumDef));
  parts.push('\n');

  return {
    filePath: `${enumDef.name}.ts`,
    content: parts.join(''),
    types: [enumDef.name],
    overwrite: true,
    category: isPluginEnum ? 'plugin-enum' : 'enum',
  };
}

/**
 * Generates a single type alias file.
 */
function generateTypeAliasFile(alias: TSTypeAlias): TypeScriptFile {
  const parts: string[] = [generateBaseHeader()];
  parts.push(formatTypeAlias(alias));
  parts.push('\n');

  return {
    filePath: `${alias.name}.ts`,
    content: parts.join(''),
    types: [alias.name],
    overwrite: true,
    category: 'enum',
  };
}

/**
 * Generates model file content that extends base.
 */
function generateModelFile(schemaName: string, options: TypeScriptOptions): TypeScriptFile {
  const basePrefix = options.baseImportPrefix ?? './base';

  // Use Zod format if enabled
  if (options.generateZodSchemas) {
    return {
      filePath: `${schemaName}.ts`,
      content: formatZodModelFile(schemaName, getImportExt(options), basePrefix),
      types: [schemaName],
      overwrite: false, // Never overwrite user models
    };
  }

  // Legacy format without Zod
  const parts: string[] = [generateModelHeader(schemaName)];
  const ext = getImportExt(options);

  // Import base interface
  parts.push(`import type { ${schemaName} as ${schemaName}Base } from '${basePrefix}/${schemaName}${ext}';\n\n`);

  // Export interface that extends base
  parts.push(`/**\n * ${schemaName} model interface.\n * Add custom properties or methods here.\n */\n`);
  parts.push(`export interface ${schemaName} extends ${schemaName}Base {\n`);
  parts.push(`  // Add custom properties here\n`);
  parts.push(`}\n\n`);

  // Re-export base for convenience
  parts.push(`// Re-export base type for internal use\n`);
  parts.push(`export type { ${schemaName}Base };\n`);

  return {
    filePath: `${schemaName}.ts`,
    content: parts.join(''),
    types: [schemaName],
    overwrite: false, // Never overwrite user models
  };
}

/**
 * Default validation messages for all supported locales.
 * Supported: en, ja, vi, ko, zh-CN (Simplified), zh-TW (Traditional), th, es
 */
const DEFAULT_VALIDATION_MESSAGES: Record<string, Record<string, string>> = {
  required: {
    en: '${displayName} is required',
    ja: '${displayName}は必須です',
    vi: '${displayName} là bắt buộc',
    ko: '${displayName}은(는) 필수입니다',
    'zh-CN': '${displayName}是必填项',
    'zh-TW': '${displayName}為必填欄位',
    th: '${displayName} จำเป็นต้องกรอก',
    es: '${displayName} es obligatorio',
  },
  minLength: {
    en: '${displayName} must be at least ${min} characters',
    ja: '${displayName}は${min}文字以上で入力してください',
    vi: '${displayName} phải có ít nhất ${min} ký tự',
    ko: '${displayName}은(는) ${min}자 이상이어야 합니다',
    'zh-CN': '${displayName}至少需要${min}个字符',
    'zh-TW': '${displayName}至少需要${min}個字元',
    th: '${displayName} ต้องมีอย่างน้อย ${min} ตัวอักษร',
    es: '${displayName} debe tener al menos ${min} caracteres',
  },
  maxLength: {
    en: '${displayName} must be at most ${max} characters',
    ja: '${displayName}は${max}文字以内で入力してください',
    vi: '${displayName} không được quá ${max} ký tự',
    ko: '${displayName}은(는) ${max}자 이하여야 합니다',
    'zh-CN': '${displayName}最多${max}个字符',
    'zh-TW': '${displayName}最多${max}個字元',
    th: '${displayName} ต้องไม่เกิน ${max} ตัวอักษร',
    es: '${displayName} debe tener como máximo ${max} caracteres',
  },
  min: {
    en: '${displayName} must be at least ${min}',
    ja: '${displayName}は${min}以上で入力してください',
    vi: '${displayName} phải lớn hơn hoặc bằng ${min}',
    ko: '${displayName}은(는) ${min} 이상이어야 합니다',
    'zh-CN': '${displayName}必须大于等于${min}',
    'zh-TW': '${displayName}必須大於等於${min}',
    th: '${displayName} ต้องมากกว่าหรือเท่ากับ ${min}',
    es: '${displayName} debe ser al menos ${min}',
  },
  max: {
    en: '${displayName} must be at most ${max}',
    ja: '${displayName}は${max}以下で入力してください',
    vi: '${displayName} phải nhỏ hơn hoặc bằng ${max}',
    ko: '${displayName}은(는) ${max} 이하여야 합니다',
    'zh-CN': '${displayName}必须小于等于${max}',
    'zh-TW': '${displayName}必須小於等於${max}',
    th: '${displayName} ต้องน้อยกว่าหรือเท่ากับ ${max}',
    es: '${displayName} debe ser como máximo ${max}',
  },
  email: {
    en: 'Please enter a valid email address',
    ja: '有効なメールアドレスを入力してください',
    vi: 'Vui lòng nhập địa chỉ email hợp lệ',
    ko: '유효한 이메일 주소를 입력하세요',
    'zh-CN': '请输入有效的电子邮件地址',
    'zh-TW': '請輸入有效的電子郵件地址',
    th: 'กรุณากรอกอีเมลที่ถูกต้อง',
    es: 'Por favor, introduce una dirección de correo electrónico válida',
  },
  url: {
    en: 'Please enter a valid URL',
    ja: '有効なURLを入力してください',
    vi: 'Vui lòng nhập URL hợp lệ',
    ko: '유효한 URL을 입력하세요',
    'zh-CN': '请输入有效的URL',
    'zh-TW': '請輸入有效的網址',
    th: 'กรุณากรอก URL ที่ถูกต้อง',
    es: 'Por favor, introduce una URL válida',
  },
  pattern: {
    en: '${displayName} format is invalid',
    ja: '${displayName}の形式が正しくありません',
    vi: '${displayName} không đúng định dạng',
    ko: '${displayName} 형식이 올바르지 않습니다',
    'zh-CN': '${displayName}格式不正确',
    'zh-TW': '${displayName}格式不正確',
    th: 'รูปแบบ${displayName}ไม่ถูกต้อง',
    es: 'El formato de ${displayName} no es válido',
  },
};

/**
 * Generates common.ts with shared types.
 */
function generateCommonFile(options: TypeScriptOptions): TypeScriptFile {
  const locales = options.localeConfig?.locales ?? ['ja', 'en'];
  const localeUnion = locales.map(l => `'${l}'`).join(' | ');

  const content = `${generateBaseHeader()}
/**
 * Locale map for multi-language support.
 */
export interface LocaleMap {
  [locale: string]: string;
}

/**
 * Supported locales in this project.
 */
export type Locale = ${localeUnion};

/**
 * Validation rule with multi-locale messages.
 * Use get{Model}Rules(locale) to get Ant Design compatible rules with string messages.
 */
export interface ValidationRule {
  required?: boolean;
  type?: 'string' | 'number' | 'email' | 'url' | 'integer' | 'array' | 'object';
  min?: number;
  max?: number;
  len?: number;
  pattern?: RegExp;
  message: LocaleMap;
}

/**
 * ISO 8601 date-time string.
 */
export type DateTimeString = string;

/**
 * ISO 8601 date string (YYYY-MM-DD).
 */
export type DateString = string;
`;

  // If base files go to node_modules, common.ts should go there too
  const isNodeModulesBase = options.baseImportPrefix?.startsWith('@');

  return {
    filePath: 'common.ts',
    content,
    types: ['LocaleMap', 'Locale', 'ValidationRule', 'DateTimeString', 'DateString'],
    overwrite: true,
    category: isNodeModulesBase ? 'base' as const : undefined,
  };
}

/**
 * Generates i18n.ts with validation messages and locale helpers.
 */
function generateI18nFile(options: TypeScriptOptions): TypeScriptFile {
  const locales = options.localeConfig?.locales ?? ['ja', 'en'];
  const defaultLocale = options.localeConfig?.defaultLocale ?? 'ja';
  const fallbackLocale = options.localeConfig?.fallbackLocale ?? 'en';
  const userMessages = options.localeConfig?.messages ?? {};

  // Merge user messages with defaults (user takes priority)
  const mergedMessages: Record<string, Record<string, string>> = {};

  // Start with defaults for supported locales only
  for (const [key, defaultMsgs] of Object.entries(DEFAULT_VALIDATION_MESSAGES)) {
    mergedMessages[key] = {};
    for (const locale of locales) {
      if (defaultMsgs[locale]) {
        mergedMessages[key][locale] = defaultMsgs[locale];
      }
    }
  }

  // Override with user messages
  for (const [key, userMsgs] of Object.entries(userMessages)) {
    if (userMsgs) {
      if (!mergedMessages[key]) {
        mergedMessages[key] = {};
      }
      for (const [locale, msg] of Object.entries(userMsgs)) {
        mergedMessages[key][locale] = msg;
      }
    }
  }

  const messagesJson = JSON.stringify(mergedMessages, null, 2);
  const ext = getImportExt(options);

  // Determine common import path based on whether base files are in node_modules
  const isNodeModulesBase = options.baseImportPrefix?.startsWith('@');
  const commonImportPath = isNodeModulesBase ? `${options.baseImportPrefix}/common` : './common';

  const content = `${generateBaseHeader()}
import type { LocaleMap } from '${commonImportPath}${ext}';

/**
 * Default locale for this project.
 */
export const defaultLocale = '${defaultLocale}' as const;

/**
 * Fallback locale when requested locale is not found.
 */
export const fallbackLocale = '${fallbackLocale}' as const;

/**
 * Supported locales in this project.
 */
export const supportedLocales = ${JSON.stringify(locales)} as const;

/**
 * Validation messages for all supported locales.
 * Use getMessage(key, locale, params) to get formatted message.
 */
export const validationMessages = ${messagesJson} as const;

/**
 * Get validation message for a specific key and locale.
 * Supports template placeholders: \${displayName}, \${min}, \${max}, etc.
 *
 * @param key - Message key (e.g., 'required', 'minLength')
 * @param locale - Locale code (e.g., 'ja', 'en')
 * @param params - Template parameters to replace
 * @returns Formatted message string
 *
 * @example
 * getMessage('required', 'ja', { displayName: '氏名' })
 * // => '氏名は必須です'
 */
export function getMessage(
  key: string,
  locale: string,
  params: Record<string, string | number> = {}
): string {
  const messages = validationMessages[key as keyof typeof validationMessages];
  if (!messages) return key;

  let message = (messages as LocaleMap)[locale]
    ?? (messages as LocaleMap)[fallbackLocale]
    ?? (messages as LocaleMap)[defaultLocale]
    ?? key;

  // Replace template placeholders
  for (const [param, value] of Object.entries(params)) {
    message = message.replace(new RegExp(\`\\\\$\\{$\{param}\\}\`, 'g'), String(value));
  }

  return message;
}

/**
 * Get all validation messages for a specific locale.
 *
 * @param locale - Locale code
 * @returns Object with all messages for the locale
 */
export function getMessages(locale: string): Record<string, string> {
  const result: Record<string, string> = {};
  for (const [key, messages] of Object.entries(validationMessages)) {
    result[key] = (messages as LocaleMap)[locale]
      ?? (messages as LocaleMap)[fallbackLocale]
      ?? (messages as LocaleMap)[defaultLocale]
      ?? key;
  }
  return result;
}
`;

  return {
    filePath: 'i18n.ts',
    content,
    types: ['validationMessages', 'getMessage', 'getMessages'],
    overwrite: true,
  };
}

/**
 * Generates index file for re-exports.
 */
function generateIndexFile(
  schemas: SchemaCollection,
  enums: TSEnum[],
  pluginEnums: TSEnum[],
  typeAliases: TSTypeAlias[],
  options: TypeScriptOptions
): TypeScriptFile {
  const parts: string[] = [generateBaseHeader()];
  const ext = getImportExt(options);

  // Determine common import path based on whether base files are in node_modules
  const isNodeModulesBase = options.baseImportPrefix?.startsWith('@');
  const commonImportPath = isNodeModulesBase ? `${options.baseImportPrefix}/common` : './common';

  // Export common types
  parts.push(`// Common Types\n`);
  parts.push(`export type { LocaleMap, Locale, ValidationRule, DateTimeString, DateString } from '${commonImportPath}${ext}';\n\n`);

  // Export i18n utilities
  parts.push(`// i18n (Internationalization)\n`);
  parts.push(`export {\n`);
  parts.push(`  defaultLocale,\n`);
  parts.push(`  fallbackLocale,\n`);
  parts.push(`  supportedLocales,\n`);
  parts.push(`  validationMessages,\n`);
  parts.push(`  getMessage,\n`);
  parts.push(`  getMessages,\n`);
  parts.push(`} from './i18n${ext}';\n\n`);

  const enumPrefix = options.enumImportPrefix ?? './enum';

  // Export schema enums (enum + Values + isX + getXLabel + getXExtra)
  if (enums.length > 0) {
    parts.push(`// Schema Enums\n`);
    for (const enumDef of enums) {
      parts.push(`export {\n`);
      parts.push(`  ${enumDef.name},\n`);
      parts.push(`  ${enumDef.name}Values,\n`);
      parts.push(`  is${enumDef.name},\n`);
      parts.push(`  get${enumDef.name}Label,\n`);
      parts.push(`  get${enumDef.name}Extra,\n`);
      parts.push(`} from '${enumPrefix}/${enumDef.name}${ext}';\n`);
    }
    parts.push('\n');
  }

  // Export plugin enums (from node_modules/.omnify/enum or legacy plugin/ subfolder)
  if (pluginEnums.length > 0) {
    const pluginEnumPrefix = options.pluginEnumImportPrefix ?? `${enumPrefix}/plugin`;
    parts.push(`// Plugin Enums\n`);
    for (const enumDef of pluginEnums) {
      parts.push(`export {\n`);
      parts.push(`  ${enumDef.name},\n`);
      parts.push(`  ${enumDef.name}Values,\n`);
      parts.push(`  is${enumDef.name},\n`);
      parts.push(`  get${enumDef.name}Label,\n`);
      parts.push(`  get${enumDef.name}Extra,\n`);
      parts.push(`} from '${pluginEnumPrefix}/${enumDef.name}${ext}';\n`);
    }
    parts.push('\n');
  }

  // Export inline enums (type aliases)
  if (typeAliases.length > 0) {
    parts.push(`// Inline Enums (Type Aliases)\n`);
    for (const alias of typeAliases) {
      parts.push(`export {\n`);
      parts.push(`  type ${alias.name},\n`);
      parts.push(`  ${alias.name}Values,\n`);
      parts.push(`  is${alias.name},\n`);
      parts.push(`  get${alias.name}Label,\n`);
      parts.push(`  get${alias.name}Extra,\n`);
      parts.push(`} from '${enumPrefix}/${alias.name}${ext}';\n`);
    }
    parts.push('\n');
  }

  // Export all models with utility types
  if (options.generateZodSchemas) {
    // Zod format: export from user model files
    parts.push(`// Models (with Zod schemas, i18n, and Create/Update types)\n`);
    for (const schema of Object.values(schemas)) {
      if (schema.kind === 'enum') continue;
      if (schema.options?.hidden === true) continue;
      const lowerName = schema.name.charAt(0).toLowerCase() + schema.name.slice(1);
      parts.push(`export type { ${schema.name}, ${schema.name}Create, ${schema.name}Update } from './${schema.name}${ext}';\n`);
      parts.push(`export {\n`);
      parts.push(`  ${lowerName}Schemas,\n`);
      parts.push(`  ${lowerName}CreateSchema,\n`);
      parts.push(`  ${lowerName}UpdateSchema,\n`);
      parts.push(`  ${lowerName}I18n,\n`);
      parts.push(`  get${schema.name}Label,\n`);
      parts.push(`  get${schema.name}FieldLabel,\n`);
      parts.push(`  get${schema.name}FieldPlaceholder,\n`);
      parts.push(`} from './${schema.name}${ext}';\n`);
    }
  } else {
    // Legacy format
    const basePrefix = options.baseImportPrefix ?? './base';
    parts.push(`// Models (with Create/Update utility types)\n`);
    for (const schema of Object.values(schemas)) {
      if (schema.kind === 'enum') continue;
      if (schema.options?.hidden === true) continue;
      parts.push(`export type { ${schema.name} } from './${schema.name}${ext}';\n`);
      parts.push(`export type { ${schema.name}Create, ${schema.name}Update } from '${basePrefix}/${schema.name}${ext}';\n`);
    }

    // Export rules functions if enabled (legacy)
    if (options.generateRules) {
      parts.push(`\n// Validation Rules\n`);
      for (const schema of Object.values(schemas)) {
        if (schema.kind === 'enum') continue;
        if (schema.options?.hidden === true) continue;
        parts.push(`export {\n`);
        parts.push(`  get${schema.name}Rules,\n`);
        parts.push(`  get${schema.name}DisplayName,\n`);
        parts.push(`  get${schema.name}PropertyDisplayName,\n`);
        parts.push(`} from './rules/${schema.name}.rules${ext}';\n`);
      }
    }
  }

  return {
    filePath: 'index.ts',
    content: parts.join(''),
    types: [],
    overwrite: true,
  };
}

/**
 * Generates TypeScript files with base/model pattern.
 *
 * Output structure:
 * - models/base/[SchemaName].ts - Auto-generated base interfaces (always overwritten)
 * - models/enum/[EnumName].ts - Auto-generated enums/type aliases (always overwritten)
 * - models/[SchemaName].ts - User-editable models that extend base (created once, never overwritten)
 * - models/index.ts - Re-exports (always overwritten)
 */
export function generateTypeScript(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TypeScriptFile[] {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const files: TypeScriptFile[] = [];

  // ========================================
  // Detect name conflicts
  // ========================================

  // Check for duplicate schema/enum names
  const schemasByName = new Map<string, string[]>(); // name -> [filePaths]
  for (const schema of Object.values(schemas)) {
    const paths = schemasByName.get(schema.name) ?? [];
    paths.push(schema.relativePath ?? schema.filePath);
    schemasByName.set(schema.name, paths);
  }

  const duplicateSchemas = Array.from(schemasByName.entries())
    .filter(([, paths]) => paths.length > 1);

  if (duplicateSchemas.length > 0) {
    const errors = duplicateSchemas.map(([name, paths]) =>
      `  - "${name}" defined in: ${paths.join(', ')}`
    ).join('\n');
    throw new Error(
      `Duplicate schema/enum names detected. Names must be globally unique:\n${errors}\n` +
      `Hint: Rename to unique names like "Blog${duplicateSchemas[0][0]}" or "Shop${duplicateSchemas[0][0]}"`
    );
  }

  // Check for conflicts between schema enums and plugin enums
  if (opts.pluginEnums && opts.pluginEnums.size > 0) {
    const conflicts: string[] = [];
    for (const schema of Object.values(schemas)) {
      if (schema.kind === 'enum' && opts.pluginEnums.has(schema.name)) {
        conflicts.push(`"${schema.name}" (schema: ${schema.relativePath ?? schema.filePath}, plugin enum)`);
      }
    }
    if (conflicts.length > 0) {
      throw new Error(
        `Schema enum conflicts with plugin enum:\n  - ${conflicts.join('\n  - ')}\n` +
        `Hint: Rename your schema enum to avoid conflict with plugin-provided enums`
      );
    }
  }

  // ========================================
  // Generate files
  // ========================================

  // Generate enum files from schema enums
  const enums = generateEnums(schemas, opts);
  for (const enumDef of enums) {
    files.push(generateEnumFile(enumDef, false)); // Schema enums in enum/
  }

  // Generate enum files from plugin enums (e.g., Prefecture, BankAccountType)
  // These go to enum/plugin/ to avoid conflicts with schema enums
  if (opts.pluginEnums && opts.pluginEnums.size > 0) {
    const pluginEnums = generatePluginEnums(opts.pluginEnums, opts);
    for (const enumDef of pluginEnums) {
      files.push(generateEnumFile(enumDef, true)); // Plugin enums in enum/plugin/
    }
  }

  // Generate inline enum files (type aliases or full enums with i18n)
  const inlineEnums = extractInlineEnums(schemas, opts);
  const inlineTypeAliases: TSTypeAlias[] = [];
  for (const item of inlineEnums) {
    if (item.enum) {
      // Full enum with i18n labels - add to enums list for index file
      enums.push(item.enum);
      files.push(generateEnumFile(item.enum, false));
    } else if (item.typeAlias) {
      // Simple type alias (no labels)
      inlineTypeAliases.push(item.typeAlias);
      files.push(generateTypeAliasFile(item.typeAlias));
    }
  }

  // Generate base interface files
  for (const schema of Object.values(schemas)) {
    if (schema.kind === 'enum') continue;
    if (schema.options?.hidden === true) continue;
    files.push(generateBaseInterfaceFile(schema.name, schemas, opts));
  }

  // Generate model files (only created if not exists)
  for (const schema of Object.values(schemas)) {
    if (schema.kind === 'enum') continue;
    if (schema.options?.hidden === true) continue;
    files.push(generateModelFile(schema.name, opts));
  }

  // Generate validation rules files (legacy, only if Zod is disabled)
  if (!opts.generateZodSchemas && opts.generateRules) {
    const rulesFiles = generateRulesFiles(schemas, opts);
    files.push(...rulesFiles);
  }

  // Generate common.ts
  files.push(generateCommonFile(opts));

  // Generate i18n.ts with validation messages
  files.push(generateI18nFile(opts));

  // Get plugin enums for index file generation
  const pluginEnumsList = opts.pluginEnums
    ? generatePluginEnums(opts.pluginEnums, opts)
    : [];

  // Generate index file
  files.push(generateIndexFile(schemas, enums, pluginEnumsList, inlineTypeAliases, opts));

  return files;
}

// Legacy exports for compatibility
export { generateTypeScript as generateTypeScriptFiles };
